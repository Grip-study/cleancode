# Ch.13 동시성

### 동시성이 필요한 이유

동시성은 **무엇**과 **언제** 의 결합을 분리하는 전략이다. 이러한 프로그램의 구조적인 개선 뿐만아니라 
응답 시간과 작업 처리량 개선이라는 요구사항에 의해 동시성 구현이 반드시 필요할 때가 있다.



### 동시성에 대한 미신과 오해

1. 동시성은 항상 성능을 높여준다.
   => 동시성은 항상 성능을 높여주진않는다. 대기시간이 길어 여러 스레드가 프로세스를 공유하거나, 여러 프로세서가 동시에 독립적으로
   계산기 가능한 경우에만 성능이 높아진다.

2. 동시성을 구현해도 설계는 변하지않는다.
   => 무엇과 언제를 어떻게 분리하느냐에따라 시스템 구조가 크게 달라진다.
3. Web 또는 EJB컨테이너를 사용하면 동시성을 이해할 필요가없다.
   => 실제로 내부적인 작동방식을 알아야 동시수정, 데드락과 같은 문제를 해결할 수 있다.



### 동시성에 대한 사실

동시성은 다소 부하를 유발한다.

동시성은 복잡하다.

동시성 버그를 재현하기가 어렵다

동시성 적용을 위해서는 근본적인 설계를 재고하거나 개편이 필요하다.



### 난관

```java
public class X {
    private int lastIdUsed;
    
    public int getNextId() {
        return ++lastIdUsed;
    }
}
```

다음 코드에서 getNextId() 메소드를 두 스레드가 호출하는 상황이 발생하면

- 쓰레드A는 43을 받음, 쓰레드B는 44를 받음, lastIdUsed는 44가됨
- 쓰레드A는 44를 받음, 쓰레드B는 43을 받음, lastIdUsed는 44가됨
- 쓰레드A는 43를 받음, 쓰레드B는 43을 받음, lastIdUsed는 43가됨

<u>**이 세가지 케이스가 모두 발생할 수 있는 가능성이 있음.**</u>



### 동시성 방어 원칙

동시성 코드의 문제점으로부터 시스템을 방어하는 원칙과 기술

- 단일 책임 원칙 SRP

  **동시성과 관련된 코드는 그렇지않은 코드와 분리되어야한다.**

  - 동시성코드는 독자적인 개발, 변경, 조율 주기가 있다.
  - 동시성 코드는 다른 코드에서 겪는 난관과 다르게 훨씬 어렵다.
  - 별의별 방식으로 실패한다. 주변의 다른코드가 발목을 잡지않더라도 이거 하나만으로 잡기 힘들다.

- 자료 범위를 제한하라

  공유 객체를 사용하는 코드 내 **임계영역**을 **synchronized** 키워드로 보호하라.

  그리고 이 임계영역의 수를 줄여라.

  **자료를 캡슐화 하고 공유 자료를 최대한 줄여라.**

- 자료 사본을 사용하라

  객체를 복사해 읽기 전용으로 사용하는 방법도 가능하다.

  어떤 경우에는 각 스레드가 객체를 복사해 사용한 후 한 스레드가 그 사본에서 결과를 가져오는 방법도 가능하다.

- 스레드는 가능한 독립적으로 구현하라

  각 스레드는 클라이언트 요청 하나를 처리하고, 다른 스레드와 **자료를 공유하지 않고 자신의 로컬 변수만 사용**한다.

  그럼 다른 스레드와 동기화 할 필요 없으므로 세상에 자신만이 있는 듯이 작동할 수 있다.

  **자료를 독립적인 단위로 분할하는 것이 중요**



### 라이브러리를 이해하라

모든 라이브러리가 스레드환경에서 안전하지는 않다.

- **ReentrantLock** : 한 메서드에서 잠그고, 다른 메서드에서 푸는 락
- **Semaphore** : 전형적인 세마포, 개수가 있는 락
- **CountDownLatch** : 지정된 수만큼 이벤트 발생한 뒤에 대기중인 스레드를 모두 해제하는 락. 모든 스레드에게 동시에 공평하게 시작할 기회를 준다.

<u>언어에서 제공하는 클래스를 검토하고 익혀라</u> (ex. java.util.concurent, java.util.concurrent.atomic, java.util.concurrent.locks in 자바)



### 실행모델을 이해하라

기본 용어

- **Bound Resource 한정된 자원** : 다중 스레드 환경에서 사용하는 자원, 크기나 숫자가 제한적. 
  e.g. 데이터베이스 연결, 길이가 일정한 읽기.쓰기 버퍼
- **Mutual Exclusion 상호 배제** : 한번에 한 스레드만 공유 자원의 사용이 가능한 경우
- **Starvation 기아** : 한 스레드가 무한히 기다리는 현상 
  e.g. 항상 짧은 스레드에게 우선순위를 주고 그 짧은 스레드가 지속적으로 이어질 경우 긴 스레드가 기아 상태에 빠질 수 있음
- **Deadlock 데드락** : 여러 스레드가 서로가 끝나기만을 기다리는 현상. 각기 필요한 자원을 다른 스레드가 점유하고있어 어느쪽도 진행하지 못함
- **Livelock 라이브락** : 공명으로 인해 락을 걸려는 시점에 다른 스레드가 서로를 방해해 오랫동안 진행하지 못하는 현상



### 식사하는 철학자들 Dining Philosophers

둥근 식탁에 철학자 여러명이 둘러 앉아있음. 각 철학자들 왼쪽에는 포크가 하나씩 놓여져있음.

스파게티를 먹으려면 왼쪽과 오른쪽에 있는 포크를 모두들어야 먹을 수 있음(왼쪽이나 오른쪽 사람이 사용하고있으면 기다려야함)

한번 스파게티를 먹은 철학자는 다시 배가고파질때까지 한동안 생각에 잠김

=> 철학자(스레드), 포크(자원) 으로 바꿔 생각해보라. 대부분의 애플리케이션이 여러 프로세스가 자원을 얻으려 이와 같이 경쟁한다.

**데드락, 라이브락, 처리율 저하, 효율성 저하** 등의 문제가 쉽게 발생할 수 있다.

<u>위 범주에 해당하는 기본 알고리즘과 각 해법을 직접 구현해보고 이해하라.</u>

 

### 동기화하는 부분을 작게 만들어라

synchronized 키워드는 락을 만들 수 있다.

락으로 감싼 영역은 한 번에 한 스레드만 실행이 가능하다.

synchronized의 남발은 속도 저하를 야기할 수 있는 바람직하지 못한 코드이지만,

임계구역이 보호받지 않으면 예상치 못한 버그가 발생한다.

<u>임계영역 수를 최대한 줄여야한다.</u>



### 올바른 종료 코드는 구현하기 어렵다.

스레드를 깔끔하게 종료하는 코드는 올바로 구현하기 어렵다.

제대로 구현되지 않으면 데드락 문제가 발생할 수 있다.

e.g. 생산자-소비자 스레드가 하나씩 있을 때, 생산자만 종료한다면 소비자는 생산자의 메시지를 영원히 기다리는 상태에 빠지게 된다.

<u>종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현해야한다. 어려운 부분일 수 있으므로 나와있는 알고리즘을 검토해라</u>



### 스레드 코드 테스트하기

문제를 노출하는 테스트 케이스를 작성하라. 프로그램 설정과 시스템 설정과 부하를 바꿔가며 자주 돌려라. 실패하면 원인을 추적하고

다시 돌렸더니 통과하더라는 이유로 넘어가면 절대 안된다.

- 말도 안되는 실패는 잠정적인 스레드 문제로 취급하라

  다중 스레드코드는 가끔 이해할 수 없는 오류를 일으킨다. 대다수 개발자가 직관적으로 이해하지 못하는 문제가 많으며, 스레드 코드에

  잠입한 버그는 수천 수백만번에 한번씩 드러나기도 해 재현하기가 어렵다. 이걸 일회성 문제로 치부하고 넘어간다면 잘못된 코드 위에 코드가

  계속 쌓일 것이다.

  **일회성이라 치부하고 넘어가지마라**

- 다중 스레드를 고려하지 않은 순차코드부터 제대로 돌게 만들자

  스레드 환경 밖에서 제대로 도는지 확인해야한다. 스레드 환경안에서 동시에 디버깅하지말고 밖에서 올바로 돌려라.

- 다중 스레드를 쓰는 코드부분을 다양한 환경에 쉽게 끼워넣을 수 있게 구현하라

  스레드의 수를 변경해가며 실행해보고 실제, 테스트 환경에서 모두 실행해보고, 반복 테스트가 가능하도록 구현해라

  **다양한 설정에서 다른 환경에 쉽게 끼워넣을 수 있게 코드를 구현해야한다**

- 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라

  적절한 스레드 개수를 파악하려면 시행착오가 필요하다. 프로그램의 성능과 처리율, 효율에따라 스레드개수를 조율하라.

- 프로세서 수보다 많은 스레드를 돌려보라

  스레드를 스와핑할때도 문제가 발생한다. 스와핑을 일으키려면 프로세서수보다 많은 스레드를 돌리면된다.

  스와핑이 잦을수록 임계영역을 빼먹은 코드나 데드락이 발생하는 코드를 찾기 쉬워진다.

- 다른 플랫폼에서 돌려보라

  플랫폼, 운영체제마다 스레드 처리 정책이 달라 결과물이 달라질 수 있으므로 모든 플랫폼에서 테스트 해봐야한다.

- 코드에 보조코드를 넣어 강제로 실패를 일으키게 해보라

  스레드 내에 발생한 오류는 찾기 어렵고, 아주 극소수의 확률로 실패한다.

  Object.wait(), Object.sleep(), Object.yield(), Object.priority() 와 같은 메소드를 코드 중간중간 추가해 드물게 발생하는 오류를 

  더 자주 일으켜볼 수 있다.

  위와 같은 보조코드를 자동으로 추가하려면 AOF, CGLIB, ASM등 자동화 도구를 사용할 수 있다. 

  (wait, sleep, yield 등의 메소드를 무작위로 호출함)



출처

임계영역 https://m.blog.naver.com/PostView.nhn?blogId=dong5053&logNo=220717508763&proxyReferer=https%3A%2F%2Fwww.google.com%2F